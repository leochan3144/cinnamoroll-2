<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cinnamoroll å†’éšª</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background-color: #FFD1DC;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      overflow: hidden;
      touch-action: manipulation;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 800px;
      height: 400px;
      margin: 0 auto;
    }
    
    #gameCanvas {
      background-color: #B5E8FF;
      display: block;
      width: 100%;
      height: 100%;
      border: 5px solid #FF9EBB;
      border-radius: 15px;
      box-shadow: 0 0 25px rgba(255, 158, 187, 0.5);
    }
    
    #uiContainer {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      padding: 15px;
      color: #FF6B8B;
      font-size: 22px;
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.8);
    }
    
    #mobileControls {
      display: none;
      width: 100%;
      max-width: 800px;
      justify-content: space-between;
      padding: 20px;
    }
    
    .mobile-btn {
      width: 85px;
      height: 85px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.8);
      border: 4px solid #FF9EBB;
      font-size: 28px;
      font-weight: bold;
      color: #FF6B8B;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 4px 8px rgba(255, 110, 140, 0.3);
    }
    
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 214, 220, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #FF6B8B;
      z-index: 10;
      text-align: center;
    }
    
    #gameOverScreen {
      display: none;
    }
    
    .screen-title {
      font-size: 52px;
      margin-bottom: 25px;
      color: #FF6B8B;
      text-shadow: 3px 3px 0 #FFFFFF;
      font-weight: bold;
    }
    
    .screen-text {
      font-size: 20px;
      margin-bottom: 30px;
      max-width: 80%;
    }
    
    .screen-btn {
      padding: 16px 35px;
      background-color: #FF9EBB;
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 22px;
      margin: 10px;
      cursor: pointer;
      box-shadow: 0 5px 0 #FF6B8B;
      transition: all 0.1s;
      font-weight: bold;
    }
    
    .screen-btn:active {
      transform: translateY(5px);
      box-shadow: none;
    }
    
    .character-display {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }
    
    .character {
      width: 80px;
      height: 80px;
      margin: 0 20px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    
    @media (max-width: 768px) {
      #mobileControls {
        display: flex;
      }
      
      #uiContainer {
        font-size: 18px;
        padding: 10px;
      }
      
      .screen-title {
        font-size: 40px;
      }
      
      .screen-btn {
        padding: 14px 30px;
        font-size: 20px;
      }
      
      .mobile-btn {
        width: 75px;
        height: 75px;
        font-size: 24px;
      }
    }
  </style>
</head>
<body>
  <div id="uiContainer">
    <div id="scoreDisplay">â­: 0</div>
    <div id="highScoreDisplay">ğŸ†: 0</div>
    <div id="livesDisplay">â¤ï¸: 3</div>
  </div>
  
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
      <h1 class="screen-title">Cinnamoroll å¤§å†’éšª</h1>
      <p class="screen-text">å¹«åŠ© Cinnamoroll æ”¶é›†æ˜Ÿæ˜Ÿï¼Œé¿é–‹ Pompompurinï¼</p>
      
      <div class="character-display">
        <div id="cinnamorollDisplay" class="character"></div>
        <div id="pompompurinDisplay" class="character"></div>
      </div>
      
      <button class="screen-btn" id="startBtn">é–‹å§‹éŠæˆ²</button>
      <button class="screen-btn" id="muteBtn">ğŸ”Š éŸ³æ•ˆé–‹å•Ÿ</button>
    </div>
    
    <div id="gameOverScreen">
      <h1 class="screen-title">éŠæˆ²çµæŸ</h1>
      <p class="screen-text" id="finalScore">ä½ æ”¶é›†äº† â­: 0</p>
      <button class="screen-btn" id="restartBtn">å†ç©ä¸€æ¬¡</button>
    </div>
  </div>
  
  <div id="mobileControls">
    <div class="mobile-btn" id="leftBtn">â†</div>
    <div class="mobile-btn" id="rightBtn">â†’</div>
    <div class="mobile-btn" id="jumpBtn">è·³èº</div>
  </div>

  <!-- éŸ³æ•ˆå…ƒç´  -->
  <audio id="bgMusic" loop>
    <source src="https://assets.mixkit.co/music/preview/mixkit-happy-children-138.mp3" type="audio/mpeg">
  </audio>
  <audio id="jumpSound">
    <source src="https://assets.mixkit.co/sfx/preview/mixkit-quick-jump-arcade-game-239.mp3" type="audio/mpeg">
  </audio>
  <audio id="collectSound">
    <source src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" type="audio/mpeg">
  </audio>
  <audio id="hitSound">
    <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3" type="audio/mpeg">
  </audio>

  <script>
    // éŠæˆ²è¨­å®š
    const config = {
      width: 800,
      height: 400,
      localStorageKey: 'cinnamorollHighScore',
      gravity: 0.5,
      playerSpeed: 6,
      jumpPower: 13,
      enemySpeed: 4,
      starPoints: 10,
      cloudCount: 8
    };
    
    // éŠæˆ²å…ƒç´ 
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const muteBtn = document.getElementById('muteBtn');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const finalScore = document.getElementById('finalScore');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    
    // éŸ³æ•ˆå…ƒç´ 
    const bgMusic = document.getElementById('bgMusic');
    const jumpSound = document.getElementById('jumpSound');
    const collectSound = document.getElementById('collectSound');
    const hitSound = document.getElementById('hitSound');
    
    // éŠæˆ²ç‹€æ…‹
    let gameState = {
      score: 0,
      highScore: localStorage.getItem(config.localStorageKey) || 0,
      lives: 3,
      isRunning: false,
      muted: false,
      keys: {
        ArrowLeft: false,
        ArrowRight: false,
        Space: false
      },
      clouds: []
    };
    
    // éŠæˆ²ç‰©ä»¶
    let player, enemies = [], stars = [], platforms = [];
    
    // é¡è‰²è¨­å®š
    const colors = {
      background: '#B5E8FF',
      cloud: '#FFFFFF',
      platform: '#FFB6C1',
      platformEdge: '#FF8FAB',
      cinnamoroll: {
        body: '#FFFFFF',
        ears: '#FFFFFF',
        cheeks: '#FFD1DC',
        eyes: '#1E88E5',
        nose: 'black',
        earShadow: '#E0F7FA',
        blush: '#FF9EBB'
      },
      pompompurin: {
        body: '#FDD835',
        hat: '#5D4037',
        hatBand: '#D32F2F',
        eyes: 'black',
        cheeks: '#FFAB91',
        mouth: '#5D4037',
        muzzle: '#FFE082'
      },
      star: '#FFD700'
    };
    
    // åˆå§‹åŒ–éŠæˆ²
    function initGame() {
      // è¨­å®šç•«å¸ƒå¤§å°
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // è¼‰å…¥æœ€é«˜åˆ†
      highScoreDisplay.textContent = `ğŸ†: ${gameState.highScore}`;
      
      // åˆå§‹åŒ–é›²æœµ
      initClouds();
      
      // äº‹ä»¶ç›£è½å™¨
      setupEventListeners();
      
      // é–‹å§‹ç•«é¢
      startBtn.addEventListener('click', startGame);
      restartBtn.addEventListener('click', startGame);
      muteBtn.addEventListener('click', toggleMute);
      
      // ç¹ªè£½é–‹å§‹ç•«é¢è§’è‰²é è¦½
      drawCharacterPreview();
      
      // é è¼‰éŸ³æ•ˆ
      bgMusic.load();
      jumpSound.load();
      collectSound.load();
      hitSound.load();
    }
    
    // åˆ‡æ›éœéŸ³
    function toggleMute() {
      gameState.muted = !gameState.muted;
      muteBtn.textContent = gameState.muted ? "ğŸ”‡ éŸ³æ•ˆé—œé–‰" : "ğŸ”Š éŸ³æ•ˆé–‹å•Ÿ";
      
      if (gameState.muted) {
        bgMusic.pause();
      } else if (gameState.isRunning) {
        bgMusic.play().catch(e => console.log("Audio play failed:", e));
      }
    }
    
    // ç¹ªè£½é–‹å§‹ç•«é¢è§’è‰²é è¦½
    function drawCharacterPreview() {
      const cinnamorollCanvas = document.createElement('canvas');
      cinnamorollCanvas.width = 100;
      cinnamorollCanvas.height = 100;
      const cinnamorollCtx = cinnamorollCanvas.getContext('2d');
      drawCinnamoroll(cinnamorollCtx, 50, 50, 40, 'right');
      document.getElementById('cinnamorollDisplay').style.backgroundImage = `url(${cinnamorollCanvas.toDataURL()})`;
      
      const pompompurinCanvas = document.createElement('canvas');
      pompompurinCanvas.width = 100;
      pompompurinCanvas.height = 100;
      const pompompurinCtx = pompompurinCanvas.getContext('2d');
      drawPompompurin(pompompurinCtx, 50, 50, 40);
      document.getElementById('pompompurinDisplay').style.backgroundImage = `url(${pompompurinCanvas.toDataURL()})`;
    }
    
    // èª¿æ•´ç•«å¸ƒå¤§å°
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      
      // æ›´æ–°éŠæˆ²è¨­å®šä¸­çš„é«˜åº¦å’Œå¯¬åº¦
      config.width = canvas.width;
      config.height = canvas.height;
      
      if (gameState.isRunning) {
        draw();
      }
    }
    
    // åˆå§‹åŒ–é›²æœµ
    function initClouds() {
      gameState.clouds = [];
      for (let i = 0; i < config.cloudCount; i++) {
        gameState.clouds.push({
          x: Math.random() * config.width,
          y: Math.random() * (config.height / 3),
          size: 20 + Math.random() * 30,
          speed: 0.2 + Math.random() * 0.5
        });
      }
    }
    
    // è¨­å®šäº‹ä»¶ç›£è½å™¨
    function setupEventListeners() {
      // éµç›¤æ§åˆ¶
      document.addEventListener('keydown', (e) => {
        if (['ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
          gameState.keys[e.code] = true;
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (['ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
          gameState.keys[e.code] = false;
          e.preventDefault();
        }
      });
      
      // æ‰‹æ©Ÿè§¸æ§æ§åˆ¶ - å·¦éµ
      leftBtn.addEventListener('touchstart', (e) => {
        gameState.keys.ArrowLeft = true;
        e.preventDefault();
      });
      
      leftBtn.addEventListener('touchend', (e) => {
        gameState.keys.ArrowLeft = false;
        e.preventDefault();
      });
      
      // æ‰‹æ©Ÿè§¸æ§æ§åˆ¶ - å³éµ
      rightBtn.addEventListener('touchstart', (e) => {
        gameState.keys.ArrowRight = true;
        e.preventDefault();
      });
      
      rightBtn.addEventListener('touchend', (e) => {
        gameState.keys.ArrowRight = false;
        e.preventDefault();
      });
      
      // æ‰‹æ©Ÿè§¸æ§æ§åˆ¶ - è·³èº
      jumpBtn.addEventListener('touchstart', (e) => {
        gameState.keys.Space = true;
        e.preventDefault();
      });
      
      jumpBtn.addEventListener('touchend', (e) => {
        gameState.keys.Space = false;
        e.preventDefault();
      });
      
      // é»æ“ŠæŒ‰éˆ•æ§åˆ¶ (ç‚ºéè§¸æ§è¨­å‚™)
      leftBtn.addEventListener('mousedown', () => gameState.keys.ArrowLeft = true);
      leftBtn.addEventListener('mouseup', () => gameState.keys.ArrowLeft = false);
      leftBtn.addEventListener('mouseleave', () => gameState.keys.ArrowLeft = false);
      
      rightBtn.addEventListener('mousedown', () => gameState.keys.ArrowRight = true);
      rightBtn.addEventListener('mouseup', () => gameState.keys.ArrowRight = false);
      rightBtn.addEventListener('mouseleave', () => gameState.keys.ArrowRight = false);
      
      jumpBtn.addEventListener('mousedown', () => gameState.keys.Space = true);
      jumpBtn.addEventListener('mouseup', () => gameState.keys.Space = false);
      jumpBtn.addEventListener('mouseleave', () => gameState.keys.Space = false);
      
      // é»æ“Šç•«é¢æ’­æ”¾èƒŒæ™¯éŸ³æ¨‚
      canvas.addEventListener('click', () => {
        if (bgMusic.paused && !gameState.muted) {
          bgMusic.play().catch(e => console.log("Audio play failed:", e));
        }
      });
    }
    
    // é–‹å§‹éŠæˆ²
    function startGame() {
      // é‡ç½®éŠæˆ²ç‹€æ…‹
      gameState.score = 0;
      gameState.lives = 3;
      gameState.isRunning = true;
      
      // éš±è—é–‹å§‹å’ŒçµæŸç•«é¢
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      
      // æ›´æ–°UI
      updateUI();
      
      // åˆå§‹åŒ–éŠæˆ²ç‰©ä»¶
      initGameObjects();
      
      // æ’­æ”¾èƒŒæ™¯éŸ³æ¨‚
      if (!gameState.muted) {
        bgMusic.currentTime = 0;
        bgMusic.play().catch(e => console.log("Audio play failed:", e));
      }
      
      // é–‹å§‹éŠæˆ²å¾ªç’°
      gameLoop();
    }
    
    // åˆå§‹åŒ–éŠæˆ²ç‰©ä»¶
    function initGameObjects() {
      // ç©å®¶ (Cinnamoroll)
      player = {
        x: 100,
        y: config.height - 150,
        width: 50,
        height: 60,
        velX: 0,
        velY: 0,
        isJumping: false,
        direction: 'right'
      };
      
      // å¹³å°
      platforms = [
        // åœ°é¢
        { x: 0, y: config.height - 50, width: config.width, height: 50 },
        // æµ®ç©ºå¹³å°
        { x: 200, y: 300, width: 150, height: 20 },
        { x: 400, y: 250, width: 150, height: 20 },
        { x: 600, y: 200, width: 150, height: 20 },
        { x: 300, y: 150, width: 100, height: 20 },
        { x: 500, y: 100, width: 100, height: 20 }
      ];
      
      // æ•µäºº (Pompompurin)
      enemies = [
        { x: 500, y: config.height - 100, width: 55, height: 55, speed: -2.5 },
        { x: 800, y: 250, width: 55, height: 55, speed: -3.2 },
        { x: 1000, y: 150, width: 55, height: 55, speed: -2.8 }
      ];
      
      // æ˜Ÿæ˜Ÿ
      stars = [
        { x: 250, y: 260, width: 30, height: 30, collected: false },
        { x: 450, y: 210, width: 30, height: 30, collected: false },
        { x: 650, y: 160, width: 30, height: 30, collected: false },
        { x: 350, y: 110, width: 30, height: 30, collected: false },
        { x: 550, y: 60, width: 30, height: 30, collected: false }
      ];
    }
    
    // éŠæˆ²å¾ªç’°
    function gameLoop() {
      if (!gameState.isRunning) return;
      
      update();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // æ›´æ–°éŠæˆ²ç‹€æ…‹
    function update() {
      // ç©å®¶ç§»å‹•
      if (gameState.keys.ArrowLeft) {
        player.velX = -config.playerSpeed;
        player.direction = 'left';
      } else if (gameState.keys.ArrowRight) {
        player.velX = config.playerSpeed;
        player.direction = 'right';
      } else {
        player.velX = 0;
      }
      
      // è·³èº
      if (gameState.keys.Space && !player.isJumping) {
        player.velY = -config.jumpPower;
        player.isJumping = true;
        if (!gameState.muted) {
          jumpSound.currentTime = 0;
          jumpSound.play().catch(e => console.log("Jump sound failed:", e));
        }
      }
      
      // æ‡‰ç”¨é‡åŠ›
      player.velY += config.gravity;
      
      // æ›´æ–°ç©å®¶ä½ç½®
      player.x += player.velX;
      player.y += player.velY;
      
      // é‚Šç•Œæª¢æŸ¥
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > config.width) player.x = config.width - player.width;
      
      // å¹³å°ç¢°æ’æª¢æ¸¬
      let onPlatform = false;
      platforms.forEach(platform => {
        if (
          player.x + player.width > platform.x &&
          player.x < platform.x + platform.width &&
          player.y + player.height >= platform.y &&
          player.y + player.height <= platform.y + platform.height / 2 &&
          player.velY > 0
        ) {
          player.y = platform.y - player.height;
          player.velY = 0;
          player.isJumping = false;
          onPlatform = true;
        }
      });
      
      // å¦‚æœä¸åœ¨å¹³å°ä¸Šï¼Œå‰‡æ¨™è¨˜ç‚ºè·³èºç‹€æ…‹
      if (!onPlatform && player.velY >= 0) {
        player.isJumping = true;
      }
      
      // æ•µäººç§»å‹•å’Œç¢°æ’æª¢æ¸¬
      enemies.forEach(enemy => {
        enemy.x += enemy.speed;
        
        // æ•µäººé‚Šç•Œæª¢æŸ¥
        if (enemy.x + enemy.width < 0) {
          enemy.x = config.width;
        } else if (enemy.x > config.width) {
          enemy.x = -enemy.width;
        }
        
        // ç©å®¶èˆ‡æ•µäººç¢°æ’
        if (checkCollision(player, enemy)) {
          playerHit();
        }
      });
      
      // æ˜Ÿæ˜Ÿæ”¶é›†
      stars.forEach(star => {
        if (!star.collected && checkCollision(player, star)) {
          star.collected = true;
          gameState.score += config.starPoints;
          updateUI();
          if (!gameState.muted) {
            collectSound.currentTime = 0;
            collectSound.play().catch(e => console.log("Collect sound failed:", e));
          }
        }
      });
      
      // æª¢æŸ¥æ˜¯å¦æ‰è½ç•«é¢åº•éƒ¨
      if (player.y > config.height) {
        playerHit();
      }
      
      // æ›´æ–°é›²æœµä½ç½®
      gameState.clouds.forEach(cloud => {
        cloud.x -= cloud.speed;
        if (cloud.x + cloud.size * 3 < 0) {
          cloud.x = config.width + cloud.size * 2;
          cloud.y = Math.random() * (config.height / 3);
        }
      });
    }
    
    // ç¢°æ’æª¢æ¸¬
    function checkCollision(obj1, obj2) {
      return (
        obj1.x < obj2.x + obj2.width &&
        obj1.x + obj1.width > obj2.x &&
        obj1.y < obj2.y + obj2.height &&
        obj1.y + obj1.height > obj2.y
      );
    }
    
    // ç©å®¶è¢«æ“Šä¸­
    function playerHit() {
      gameState.lives--;
      updateUI();
      
      if (!gameState.muted) {
        hitSound.currentTime = 0;
        hitSound.play().catch(e => console.log("Hit sound failed:", e));
      }
      
      if (gameState.lives <= 0) {
        gameOver();
      } else {
        // é‡ç½®ç©å®¶ä½ç½®
        player.x = 100;
        player.y = config.height - 150;
        player.velY = 0;
        player.isJumping = false;
      }
    }
    
    // éŠæˆ²çµæŸ
    function gameOver() {
      gameState.isRunning = false;
      bgMusic.pause();
      
      // æ›´æ–°æœ€é«˜åˆ†
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem(config.localStorageKey, gameState.highScore);
        highScoreDisplay.textContent = `ğŸ†: ${gameState.highScore}`;
      }
      
      // é¡¯ç¤ºçµæŸç•«é¢
      finalScore.textContent = `ä½ æ”¶é›†äº† â­: ${gameState.score}`;
      gameOverScreen.style.display = 'flex';
    }
    
    // æ›´æ–°UI
    function updateUI() {
      scoreDisplay.textContent = `â­: ${gameState.score}`;
      livesDisplay.textContent = `â¤ï¸: ${gameState.lives}`;
    }
    
    // ç¹ªè£½éŠæˆ²
    function draw() {
      // æ¸…ç©ºç•«å¸ƒ
      ctx.clearRect(0, 0, config.width, config.height);
      
      // ç¹ªè£½èƒŒæ™¯
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, config.width, config.height);
      
      // ç¹ªè£½é›²æœµ
      ctx.fillStyle = colors.cloud;
      gameState.clouds.forEach(cloud => {
        drawCloud(ctx, cloud.x, cloud.y, cloud.size);
      });
      
      // ç¹ªè£½å¹³å°
      platforms.forEach(platform => {
        // å¹³å°ä¸»é«”
        ctx.fillStyle = colors.platform;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        
        // å¹³å°é‚Šç·£
        ctx.fillStyle = colors.platformEdge;
        ctx.fillRect(platform.x, platform.y, platform.width, 5);
        ctx.fillRect(platform.x, platform.y + platform.height - 5, platform.width, 5);
      });
      
      // ç¹ªè£½æ˜Ÿæ˜Ÿ
      stars.forEach(star => {
        if (!star.collected) {
          ctx.fillStyle = colors.star;
          drawStar(ctx, star.x + star.width/2, star.y + star.height/2, 5, star.width/2, star.height/4);
        }
      });
      
      // ç¹ªè£½æ•µäºº (Pompompurin)
      enemies.forEach(enemy => {
        drawPompompurin(ctx, enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/2);
      });
      
      // ç¹ªè£½ç©å®¶ (Cinnamoroll)
      drawCinnamoroll(
        ctx, 
        player.x + player.width/2, 
        player.y + player.height/2, 
        player.width/2, 
        player.direction
      );
    }
    
    // ç¹ªè£½ Cinnamoroll (çµ‚æ¥µç²¾ç´°ç‰ˆ)
    function drawCinnamoroll(ctx, x, y, size, direction) {
      ctx.save();
      
      // æ ¹æ“šæ–¹å‘æ±ºå®šæ˜¯å¦ç¿»è½‰
      if (direction === 'left') {
        ctx.translate(x * 2, 0);
        ctx.scale(-1, 1);
      }
      
      // èº«é«” (åœ“å½¢)
      ctx.fillStyle = colors.cinnamoroll.body;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
      
      // è€³æœµé™°å½± (æ›´ç«‹é«”)
      ctx.fillStyle = colors.cinnamoroll.earShadow;
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.ellipse(
          x - size * 0.6, 
          y - size * 0.8 + i * 2, 
          size * 0.5, 
          size * 0.7, 
          -Math.PI/6, 0, Math.PI * 2
        );
        ctx.fill();
        
        ctx.beginPath();
        ctx.ellipse(
          x + size * 0.6, 
          y - size * 0.8 + i * 2, 
          size * 0.5, 
          size * 0.7, 
          Math.PI/6, 0, Math.PI * 2
        );
        ctx.fill();
      }
      
      // è€³æœµ (æ›´è“¬é¬†)
      ctx.fillStyle = colors.cinnamoroll.ears;
      ctx.beginPath();
      ctx.ellipse(
        x - size * 0.6, 
        y - size * 0.8, 
        size * 0.45, 
        size * 0.65, 
        -Math.PI/6, 0, Math.PI * 2
      );
      ctx.fill();
      
      ctx.beginPath();
      ctx.ellipse(
        x + size * 0.6, 
        y - size * 0.8, 
        size * 0.45, 
        size * 0.65, 
        Math.PI/6, 0, Math.PI * 2
      );
      ctx.fill();
      
      // è‡‰é °ç´…æšˆ (æ›´è‡ªç„¶)
      ctx.fillStyle = colors.cinnamoroll.blush;
      ctx.beginPath();
      ctx.arc(x - size * 0.3, y + size * 0.1, size * 0.15, 0, Math.PI * 2);
      ctx.arc(x + size * 0.3, y + size * 0.1, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      
      // çœ¼ç› (æ›´ç”Ÿå‹•çš„æ©¢åœ“å½¢)
      ctx.fillStyle = colors.cinnamoroll.eyes;
      ctx.beginPath();
      ctx.ellipse(
        x - size * 0.2, 
        y - size * 0.1, 
        size * 0.08, 
        size * 0.12, 
        0, 0, Math.PI * 2
      );
      ctx.ellipse(
        x + size * 0.2, 
        y - size * 0.1, 
        size * 0.08, 
        size * 0.12, 
        0, 0, Math.PI * 2
      );
      ctx.fill();
      
      // çœ¼ç›é«˜å…‰
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(x - size * 0.22, y - size * 0.12, size * 0.03, 0, Math.PI * 2);
      ctx.arc(x + size * 0.18, y - size * 0.12, size * 0.03, 0, Math.PI * 2);
      ctx.fill();
      
      // é¼»å­ (æ›´ç«‹é«”)
      ctx.fillStyle = colors.cinnamoroll.nose;
      ctx.beginPath();
      ctx.arc(x, y, size * 0.08, 0, Math.PI * 2);
      ctx.fill();
      
      // å˜´å·´ (å¾®ç¬‘æ›²ç·š)
      ctx.strokeStyle = colors.cinnamoroll.nose;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y + size * 0.05, size * 0.05, 0, Math.PI);
      ctx.stroke();
      
      ctx.restore();
    }
    
    // ç¹ªè£½ Pompompurin (çµ‚æ¥µç²¾ç´°ç‰ˆ)
    function drawPompompurin(ctx, x, y, size) {
      // èº«é«” (åœ“å½¢ï¼Œå¸¶é™°å½±)
      const bodyGradient = ctx.createRadialGradient(
        x, y - size * 0.2, size * 0.1,
        x, y, size
      );
      bodyGradient.addColorStop(0, '#FFEB3B');
      bodyGradient.addColorStop(1, '#FBC02D');
      
      ctx.fillStyle = bodyGradient;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
      
      // å£é¼»éƒ¨
      ctx.fillStyle = colors.pompompurin.muzzle;
      ctx.beginPath();
      ctx.ellipse(x, y + size * 0.1, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // å¸½å­åº•éƒ¨ (å¸¶é™°å½±)
      const hatGradient = ctx.createLinearGradient(
        x, y - size * 0.7,
        x, y - size * 0.3
      );
      hatGradient.addColorStop(0, '#4E342E');
      hatGradient.addColorStop(1, '#3E2723');
      
      ctx.fillStyle = hatGradient;
      ctx.beginPath();
      ctx.ellipse(x, y - size * 0.5, size * 0.9, size * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // å¸½å­é ‚éƒ¨
      ctx.beginPath();
      ctx.ellipse(x, y - size * 0.7, size * 0.7, size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // å¸½å­å¸¶ (æ›´ç«‹é«”)
      const bandGradient = ctx.createLinearGradient(
        x, y - size * 0.55,
        x, y - size * 0.45
      );
      bandGradient.addColorStop(0, '#E53935');
      bandGradient.addColorStop(1, '#C62828');
      
      ctx.fillStyle = bandGradient;
      ctx.beginPath();
      ctx.ellipse(x, y - size * 0.5, size * 0.9, size * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // çœ¼ç› (æ›´ç”Ÿå‹•)
      ctx.fillStyle = colors.pompompurin.eyes;
      ctx.beginPath();
      ctx.ellipse(
        x - size * 0.2, 
        y - size * 0.1, 
        size * 0.08, 
        size * 0.12, 
        0, 0, Math.PI * 2
      );
      ctx.ellipse(
        x + size * 0.2, 
        y - size * 0.1, 
        size * 0.08, 
        size * 0.12, 
        0, 0, Math.PI * 2
      );
      ctx.fill();
      
      // çœ¼ç›é«˜å…‰
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(x - size * 0.22, y - size * 0.12, size * 0.03, 0, Math.PI * 2);
      ctx.arc(x + size * 0.18, y - size * 0.12, size * 0.03, 0, Math.PI * 2);
      ctx.fill();
      
      // è‡‰é °ç´…æšˆ
      ctx.fillStyle = colors.pompompurin.cheeks;
      ctx.beginPath();
      ctx.arc(x - size * 0.3, y + size * 0.1, size * 0.15, 0, Math.PI * 2);
      ctx.arc(x + size * 0.3, y + size * 0.1, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      
      // å˜´å·´ (å¾®ç¬‘æ›²ç·š)
      ctx.strokeStyle = colors.pompompurin.mouth;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y + size * 0.15, size * 0.1, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.stroke();
      
      // é¼»å­
      ctx.fillStyle = colors.pompompurin.mouth;
      ctx.beginPath();
      ctx.arc(x, y + size * 0.05, size * 0.04, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // ç¹ªè£½é›²æœµ
    function drawCloud(ctx, x, y, size) {
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.arc(x + size * 1.3, y, size * 1.3, 0, Math.PI * 2);
      ctx.arc(x + size * 2.5, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // ç¹ªè£½æ˜Ÿæ˜Ÿå½¢ç‹€
    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy;
      let step = Math.PI / spikes;
      
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
      
      // æ·»åŠ æ˜Ÿæ˜Ÿå…‰æšˆ
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, outerRadius);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    // åˆå§‹åŒ–éŠæˆ²
    initGame();
  </script>
</body>
</html>